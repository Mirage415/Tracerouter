<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Voice Control Traceroute Visualization</title>
  <!-- Basic Libraries -->
  <!-- Âè™‰øùÁïôp5.jsÂíåp5.sound.min.jsÔºåÁî®‰∫éÂä®ÁîªÊòæÁ§∫ -->
  <script src="lib/p5/p5.min.js"></script>
  <script src="lib/p5/addons/p5.sound.min.js"></script>

  <!-- ÂºïÂÖ•nodejs-whisperÁõ∏ÂÖ≥ÁöÑÂ∫ì -->
  <script src="../node_modules/nodejs-whisper/dist/nodejs-whisper.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
    }

    #ui-panel {
      position: absolute;
      left: 20px;
      top: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      width: 300px;
    }

    #control-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    button {
      background: #05c9fa;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    button:disabled {
      background: #666;
      cursor: not-allowed;
    }

    #result {
      margin-top: 10px;
      font-size: 1.2em;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 5px;
      min-height: 1.5em;
    }

    /* Result label styles */
    .result-label {
      font-size: 0.8em;
      color: #05c9fa;
      margin-bottom: 5px;
      font-weight: bold;
    }

    /* Enhanced result area styles */
    .result-content {
      padding: 8px;
      background: rgba(5, 201, 250, 0.1);
      border-left: 3px solid #05c9fa;
      word-break: break-all;
    }

    #output-panel {
      position: absolute;
      left: 20px;
      top: 180px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      width: 400px;
      max-height: 60vh;
      overflow-y: auto;
    }

    #traceOutput {
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 0.9em;
      color: #ddd;
    }

    #debugPanel {
      position: absolute;
      right: 20px;
      top: 20px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 10px;
      width: 300px;
      max-height: 60vh;
      overflow-y: auto;
    }

    #debugOutput {
      font-family: monospace;
      white-space: pre-wrap;
      font-size: 0.9em;
      color: #0f0;
    }

    h3 {
      margin-top: 0;
      color: #05c9fa;
    }

    #rawInput {
      margin-top: 10px;
      width: 90%;
      padding: 8px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 5px;
      color: white;
    }

    #submitBtn {
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <div id="ui-panel">
    <h3>Voice Control Traceroute</h3>
    <div id="control-buttons">
      <button id="startBtn">üéôÔ∏è Start Recognition</button>
      <button id="stopBtn" disabled>‚èπÔ∏è Stop Recognition</button>
      <button id="testBtn">Test API</button>
    </div>
    <div id="result">
      <div class="result-label">Recognition Result</div>
      <div class="result-content">(Not started)</div>
    </div>
    <p style="font-size:0.8em;color:#ccc;">Say a domain name, for example: "google.com" or "baidu"</p>

    <!-- <button id="exportOptionsBtn">Output json</button> -->
     <!-- Âú®ÂêàÈÄÇ‰ΩçÁΩÆÂä†ÊåâÈíÆ -->
<button id="exportOptionsBtn">Export</button>

<!-- ÂºπÁ™óË°®ÂçïÔºàÂàùÂßãÈöêËóèÔºâ -->
<div id="optionsModal" style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:100;background:rgba(0,0,0,0.4);">
  <div style="background:#222;padding:20px;border-radius:8px;position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);min-width:350px;">
    <h3 style="margin-top:0;">Edit</h3>
    <form id="optionsForm">
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">package_size</label>
        <input name="package_size" type="number" value="64" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">series_count</label>
        <input name="series_count" type="number" value="1" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">probe_sequence</label>
        <input name="probe_sequence" type="text" value="udp,tcp,icmp" placeholder="Áî®ÈÄóÂè∑ÂàÜÈöî" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">queries</label>
        <input name="queries" type="number" value="1" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">series_interval</label>
        <input name="series_interval" type="number" value="100" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">z</label>
        <input name="z" type="number" value="0" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">max_hops</label>
        <input name="max_hops" type="number" value="30" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">wait</label>
        <input name="wait" type="number" value="5000" />
      </div>
      <div style="display:flex;align-items:center;margin-bottom:8px;">
        <label style="width:120px;">no_resolve</label>
        <select name="no_resolve">
          <option value="false">False</option>
          <option value="true">True</option>
        </select>
      </div>
      <div style="text-align:right;">
        <button type="button" id="exportOptionsSubmit">Export</button>
        <button type="button" id="exportOptionsCancel">Cancel</button>
      </div>
    </form>
  </div>
</div>

<script>
// ÊòæÁ§∫ÂºπÁ™ó
document.getElementById('exportOptionsBtn').onclick = () => {
  document.getElementById('optionsModal').style.display = 'block';
};
// ÂèñÊ∂àÊåâÈíÆ
document.getElementById('exportOptionsCancel').onclick = () => {
  document.getElementById('optionsModal').style.display = 'none';
};
// ÂØºÂá∫ÊåâÈíÆ
document.getElementById('exportOptionsSubmit').onclick = () => {
  const form = document.getElementById('optionsForm');
  const data = new FormData(form);
  const options = {
    package_size: Number(data.get('package_size')),
    series_count: Number(data.get('series_count')),
    probe_sequence: data.get('probe_sequence').split(',').map(s=>s.trim()),
    queries: Number(data.get('queries')),
    series_interval: Number(data.get('series_interval')),
    z: Number(data.get('z')),
    max_hops: Number(data.get('max_hops')),
    wait: Number(data.get('wait')),
    no_resolve: data.get('no_resolve') === 'true'
  };
  // Áõ¥Êé•‰øùÂ≠òÂà∞rendererÁõÆÂΩï‰∏ãÔºåÊó†ÈúÄÂºπÁ™ó
  if (window.api && window.api.saveFileToRendererDir) {
    // Electron ÁéØÂ¢ÉÔºåË∞ÉÁî®‰∏ªËøõÁ®ãAPI‰øùÂ≠òÊñá‰ª∂
    window.api.saveFileToRendererDir('option.json', JSON.stringify(options, null, 2))
      .then(() => {
        debugLog('option.json Â∑≤‰øùÂ≠òÂà∞ renderer ÁõÆÂΩï');
      })
      .catch(err => {
        debugLog('‰øùÂ≠ò option.json Â§±Ë¥•: ' + err.message);
      });
  } else {
    debugLog('Electron API ‰∏çÂèØÁî®ÔºåÊó†Ê≥ïÁõ¥Êé•‰øùÂ≠òÂà∞ renderer ÁõÆÂΩï');
  }
  const blob = new Blob([JSON.stringify(options, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'option.json'; // Êñá‰ª∂ÂêçÂõ∫ÂÆö‰∏∫ option.json
  a.click();
  document.getElementById('optionsModal').style.display = 'none';
};
</script>


    <!-- <button id="batchBtn">batch input</button>
    <div id="batchModal" style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:100;background:rgba(0,0,0,0.4);">
      <div style="background:#222;padding:20px;border-radius:8px;position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);min-width:300px;">
        <h3 style="margin-top:0;">Please input file directory</h3>
        <input id="batchFileInput" type="text" style="width:90%;" placeholder="E.g. /Users/xxx/targets.txt">
        <div style="margin-top:10px;text-align:right;">
          <button id="batchSubmitBtn">Submit</button>
          <button id="batchCancelBtn">Cancel</button>
        </div>
      </div>
    </div> -->
    <!-- Add manual input field -->
    <input type="text" id="rawInput" placeholder="Or directly enter domain name...">
    <button id="submitBtn">Submit</button>
  </div>

  <div id="output-panel" style="top: 400px;">
    <h3>Execution Result:</h3>
    <div id="traceOutput"></div>
  </div>

  <!-- Debug information panel -->
  <div id="debugPanel">
    <h3>Debug Information:</h3>
    <div id="debugOutput">Waiting for debug info...</div>
    <!-- Add dedicated recognition result debug area -->
    <h3 style="margin-top: 15px; color: #ff0;">Recognition Text Debug:</h3>
    <div id="recognitionDebug"
      style="color: #ff0; font-weight: bold; background: rgba(0,0,0,0.5); padding: 8px; margin-top: 5px;">Waiting for
      voice input...
    </div>



  </div>






  <script>
    // Auto-execute traceroute when input changes and loses focus or Enter key is pressed
    const rawInput = document.getElementById('rawInput');
    rawInput.addEventListener('change', () => {
      const domain = rawInput.value.trim();
      if (domain) {
        debugLog(`Auto input domain: ${domain}`);
        const resultElement = document.getElementById('result');
        let resultContent = resultElement.querySelector('.result-content');
        if (resultContent) {
          resultContent.textContent = domain;
        } else {
          resultElement.innerHTML = `<div class="result-label">Recognition Result</div><div class="result-content">${domain}</div>`;
        }
        processCommand(domain);
        rawInput.value = '';
      }
    });
    rawInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const domain = rawInput.value.trim();
        if (domain) {
          debugLog(`Auto input domain: ${domain}`);
          const resultElement = document.getElementById('result');
          let resultContent = resultElement.querySelector('.result-content');
          if (resultContent) {
            resultContent.textContent = domain;
          } else {
            resultElement.innerHTML = `<div class="result-label">Recognition Result</div><div class="result-content">${domain}</div>`;
          }
          processCommand(domain);
          rawInput.value = '';
        }
      }
    });
  </script>

  <script>
    // Add debug log function
    function debugLog(message) {
      const debugElem = document.getElementById('debugOutput');
      const timestamp = new Date().toLocaleTimeString();
      debugElem.innerHTML += `[${timestamp}] ${message}\n`;
      debugElem.scrollTop = debugElem.scrollHeight;
      console.log(`[DEBUG] ${message}`);
    }

    // Add dedicated recognition text log function
    function recognitionLog(text) {
      const recognitionDebug = document.getElementById('recognitionDebug');
      if (recognitionDebug) {
        recognitionDebug.innerHTML = `<span style="color:#f0f;">"${text || 'No text'}"</span>`;
        console.log(`[RECOGNITION] "${text}"`);
      }
    }

    // Nodejs-Whisper ËØ≠Èü≥ËØÜÂà´Áõ∏ÂÖ≥‰ª£Á†Å
    let isRecognizing = false;
    let audioRecorder = null;
    let audioChunks = [];
    let tempAudioFile = null;

    // ÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´
    async function initAudioCapture() {
      try {
        debugLog("Ê≠£Âú®ÂàùÂßãÂåñÈü≥È¢ëÊçïËé∑...");

        // Â∞ùËØï‰ΩøÁî®Web Speech API‰Ωú‰∏∫Â§áÈÄâÊñπÊ°à
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
          debugLog("Ê£ÄÊµãÂà∞Web Speech APIÂèØÁî®ÔºåÂ∞Ü‰Ωú‰∏∫Â§áÈÄâÊñπÊ°à");
          window.webSpeechBackup = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
          window.webSpeechBackup.lang = 'zh-CN'; // ËÆæÁΩÆ‰∏∫‰∏≠Êñá
          window.webSpeechBackup.continuous = false;
          window.webSpeechBackup.interimResults = false;

          window.webSpeechBackup.onresult = function (event) {
            const transcript = event.results[0][0].transcript;
            debugLog(`Web Speech API ËØÜÂà´ÁªìÊûú: "${transcript}"`);
            recognitionLog(transcript);

            // Êõ¥Êñ∞UI
            const resultElement = document.getElementById('result');
            let resultContent = resultElement.querySelector('.result-content');
            if (resultContent) {
              resultContent.textContent = transcript || '(Êú™Ê£ÄÊµãÂà∞ËØ≠Èü≥)';
            } else {
              resultElement.innerHTML = `<div class="result-label">ËØÜÂà´ÁªìÊûú</div><div class="result-content">${transcript || '(Êú™Ê£ÄÊµãÂà∞ËØ≠Èü≥)'}</div>`;
            }

            // Â§ÑÁêÜÂëΩ‰ª§
            if (transcript) {
              processCommand(transcript);
            }
          };

          window.webSpeechBackup.onerror = function (event) {
            debugLog(`Web Speech API ÈîôËØØ: ${event.error}`);
          };
        }

        // Ëé∑ÂèñÈ∫¶ÂÖãÈ£éÊµÅ
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        debugLog("È∫¶ÂÖãÈ£éËÆøÈóÆÊùÉÈôêÂ∑≤Ëé∑Âèñ");

        // ÂàõÂª∫MediaRecorder
        audioRecorder = new MediaRecorder(stream);

        // ÁõëÂê¨Êï∞ÊçÆÂèØÁî®‰∫ã‰ª∂
        audioRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        // ÁõëÂê¨ÂΩïÈü≥ÂÅúÊ≠¢‰∫ã‰ª∂
        audioRecorder.onstop = async () => {
          if (audioChunks.length === 0) {
            debugLog("Ê≤°ÊúâÊî∂ÈõÜÂà∞Èü≥È¢ëÊï∞ÊçÆ");
            return;
          }

          try {
            debugLog("ÂºÄÂßãÂ§ÑÁêÜÈü≥È¢ë...");
            const resultElement = document.getElementById('result');
            let resultContent = resultElement.querySelector('.result-content');
            if (resultContent) {
              resultContent.textContent = "Ê≠£Âú®ËØÜÂà´...";
            }

            // ÂàõÂª∫Èü≥È¢ëBlob
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            audioChunks = []; // Ê∏ÖÁ©∫Êï∞ÁªÑ‰ª•‰æø‰∏ãÊ¨°ÂΩïÈü≥

            // Âú®ElectronÁéØÂ¢É‰∏≠Â§ÑÁêÜÈü≥È¢ë 
            if (hasElectronAPI) {
              // Âêë‰∏ªËøõÁ®ãÂèëÈÄÅÈü≥È¢ëÊï∞ÊçÆËøõË°åÂ§ÑÁêÜ
              debugLog("ÂèëÈÄÅÈü≥È¢ëÂà∞‰∏ªËøõÁ®ãËøõË°åWhisperÂ§ÑÁêÜ");

              // Â∞ÜBlobËΩ¨Êç¢‰∏∫ArrayBuffer
              const arrayBuffer = await audioBlob.arrayBuffer();
              const uint8Array = new Uint8Array(arrayBuffer);

              // ‰ΩøÁî®‰∏¥Êó∂Êñá‰ª∂‰øùÂ≠òÈü≥È¢ë
              const tempFileName = `temp_audio_${Date.now()}.wav`;

              // ÈÄöËøáElectron IPCË∞ÉÁî®nodejs-whisperÂ§ÑÁêÜ
              // ËøôÈúÄË¶ÅÂú®preload.jsÂíåmain.js‰∏≠Ê∑ªÂä†Áõ∏Â∫îÁöÑAPI
              window.api.processWhisperAudio(uint8Array, tempFileName)
                .then(transcription => {
                  debugLog(`WhisperËØÜÂà´ÁªìÊûú: "${transcription}"`);

                  // Êõ¥Êñ∞UI
                  if (resultContent) {
                    resultContent.textContent = transcription || '(Êú™Ê£ÄÊµãÂà∞ËØ≠Èü≥)';
                  }

                  // ËØÜÂà´Âà∞ÂÜÖÂÆπÂêéÂ§ÑÁêÜÂëΩ‰ª§
                  if (transcription) {
                    processCommand(transcription);
                  }

                  // Â¶ÇÊûú‰ªçÂ§Ñ‰∫éËØÜÂà´Áä∂ÊÄÅÔºåÁªßÁª≠ÂΩïÈü≥
                  if (isRecognizing) {
                    startRecording();
                  }
                })
                .catch(error => {
                  debugLog(`Èü≥È¢ëÂ§ÑÁêÜÈîôËØØ: ${error.message}`);
                  console.error("Èü≥È¢ëÂ§ÑÁêÜÈîôËØØ:", error);

                  // Â∞ùËØï‰ΩøÁî®Web Speech API‰Ωú‰∏∫Â§áÈÄâ
                  if (window.webSpeechBackup) {
                    debugLog("Â∞ùËØï‰ΩøÁî®Web Speech API‰Ωú‰∏∫Â§áÈÄâÊñπÊ°à");
                    try {
                      window.webSpeechBackup.start();
                      debugLog("Â∑≤ÂêØÂä®Web Speech APIÂ§áÈÄâËØÜÂà´");
                    } catch (webError) {
                      debugLog(`Web Speech APIÂêØÂä®Â§±Ë¥•: ${webError.message}`);
                    }
                  }
                });
            } else {
              debugLog("Êó†Ê≥ïÂ§ÑÁêÜÈü≥È¢ëÔºöElectron API‰∏çÂèØÁî®");
              if (resultContent) {
                resultContent.textContent = "Êó†Ê≥ïÂ§ÑÁêÜÈü≥È¢ëÔºöElectron API‰∏çÂèØÁî®";
              }
            }
          } catch (error) {
            debugLog(`Èü≥È¢ëÂ§ÑÁêÜÈîôËØØ: ${error.message}`);
            console.error("Èü≥È¢ëÂ§ÑÁêÜÈîôËØØ:", error);
          }
        };

        return true;
      } catch (error) {
        debugLog(`Èü≥È¢ëÊçïËé∑ÂàùÂßãÂåñÂ§±Ë¥•: ${error.message}`);
        console.error("Èü≥È¢ëÊçïËé∑ÂàùÂßãÂåñÈîôËØØ:", error);
        return false;
      }
    }

    // ÂºÄÂßãÂΩïÈü≥
    function startRecording() {
      if (!audioRecorder || audioRecorder.state === 'recording') {
        return;
      }

      try {
        audioChunks = [];
        audioRecorder.start();
        debugLog("ÂºÄÂßãÂΩïÈü≥...");

        // ËÆæÁΩÆ‰∏Ä‰∏™Ë∂ÖÊó∂Ôºå5ÁßíÂÅúÊ≠¢‰∏ÄÊ¨°ÂΩïÈü≥Âπ∂ËøõË°åÂ§ÑÁêÜ
        setTimeout(() => {
          if (audioRecorder && audioRecorder.state === 'recording') {
            audioRecorder.stop();
            debugLog("ÂΩïÈü≥ÊÆµÂ∑≤ÁªìÊùüÔºåÊ≠£Âú®Â§ÑÁêÜ...");
          }
        }, 5000);
      } catch (error) {
        debugLog(`ÂºÄÂßãÂΩïÈü≥Â§±Ë¥•: ${error.message}`);
      }
    }

    // ÂÅúÊ≠¢ÂΩïÈü≥
    function stopRecording() {
      if (!audioRecorder || audioRecorder.state !== 'recording') {
        return;
      }

      try {
        audioRecorder.stop();
        debugLog("ÂΩïÈü≥Â∑≤ÂÅúÊ≠¢");

        // ÂêåÊó∂ÂÅúÊ≠¢Web Speech APIÂ§áÈÄâÊñπÊ°à
        if (window.webSpeechBackup) {
          try {
            window.webSpeechBackup.stop();
            debugLog("Web Speech APIÂ§áÈÄâÊñπÊ°àÂ∑≤ÂÅúÊ≠¢");
          } catch (e) {
            debugLog(`ÂÅúÊ≠¢Web Speech APIÈîôËØØ: ${e.message}`);
          }
        }
      } catch (error) {
        debugLog(`ÂÅúÊ≠¢ÂΩïÈü≥Â§±Ë¥•: ${error.message}`);
      }
    }

    // Process domain formatting
    function formatDomain(text) {
      // Remove possible "traceroute" keyword
      let domain = text.toLowerCase().replace(/traceroute\s+/g, '').trim();

      // Remove trailing punctuation (like period, comma, exclamation mark, etc.)
      domain = domain.replace(/[.,!?;:'"Ôºâ„Äë„Äã„ÄâÔºâ]\s*$/g, '').trim();

      // Remove punctuation and special characters from the beginning and end
      domain = domain.replace(/^[\s"'„Ää„ÄêÔºà\['"\(]+|[\s"'„Äã„ÄëÔºâ\]'"\)]+$/g, '').trim();

      // Handle common domain shortcuts
      const domainMap = {
        'google': 'google.com',
        'baidu': 'baidu.com',
        'bing': 'bing.com',
        'yahoo': 'yahoo.com',
        'taobao': 'taobao.com',
        'microsoft': 'microsoft.com',
        'tencent': 'qq.com',
        'netease': '163.com'
      };

      // Check if it's a common domain shortcut
      if (domainMap[domain]) {
        domain = domainMap[domain];
      }

      // If there's no .com, .cn or other suffix, automatically add .com
      if (!/\.\w+$/.test(domain)) {
        domain = domain + '.com';
      }

      // Ensure domain format is correct (only contains letters, numbers, dots and hyphens)
      if (!/^[a-z0-9.-]+\.[a-z]{2,}$/i.test(domain)) {
        // Try to fix common issues
        domain = domain
          // Remove all spaces
          .replace(/\s+/g, '')
          // Reduce multiple dots to a single dot
          .replace(/\.{2,}/g, '.')
          // Clean trailing dots
          .replace(/\.$/, '');
      }

      debugLog(`ÂéüÂßãËæìÂÖ•: "${text}" -> Â§ÑÁêÜÂêéÂüüÂêç: "${domain}"`);
      return domain;
    }

    // Check if Electron API is available (running in packaged app)
    const hasElectronAPI = window.api && window.api.runTraceroute && window.api.onOutput;
    debugLog(`Electron API ÂèØÁî®: ${hasElectronAPI}`);
    if (!hasElectronAPI) {
      debugLog("Ë≠¶Âëä: Electron API ‰∏çÂèØÁî®ÔºåÊüê‰∫õÂäüËÉΩÂ∞ÜÊó†Ê≥ïÂ∑•‰Ωú");
    }

    // Process recognized command
    function processCommand(txt) {
      // Standardize as domain format
      const domain = formatDomain(txt);
      debugLog(`Â§ÑÁêÜÂêéÂüüÂêç: ${domain}`);

      // Construct complete traceroute command
      const command = `traceroute ${domain}`;

      if (hasElectronAPI) {
        debugLog(`ÊâßË°åÂëΩ‰ª§: ${command}`);
        document.getElementById('traceOutput').innerHTML = `ÊâßË°å: ${command}\nÊ≠£Âú®ËøΩË∏™Ë∑ØÁî±...\n`;
        // Call main process through API exposed in preload.js
        window.api.runTraceroute(command);
      } else {
        debugLog(`Êó†Ê≥ïÊâßË°åÂëΩ‰ª§: Electron API ‰∏çÂèØÁî®`);
        document.getElementById('traceOutput').innerHTML = "ÈîôËØØ: Electron API ‰∏çÂèØÁî®ÔºåÊó†Ê≥ïÊâßË°åÂëΩ‰ª§\n";
      }
    }

    // Ê∑ªÂä†ÊåâÈíÆ‰∫ã‰ª∂Â§ÑÁêÜ
    document.getElementById('startBtn').onclick = async () => {
      try {
        debugLog("ÂºÄÂßãËØ≠Èü≥ËØÜÂà´...");

        // ÂàùÂßãÂåñÈü≥È¢ëÊçïËé∑ÔºàÂ¶ÇÊûúÊú™ÂàùÂßãÂåñÔºâ
        if (!audioRecorder) {
          const audioInitialized = await initAudioCapture();
          if (!audioInitialized) {
            throw new Error("Êó†Ê≥ïÂàùÂßãÂåñÈü≥È¢ëÊçïËé∑");
          }
        }

        // Êõ¥Êñ∞UI
        const resultElement = document.getElementById('result');
        let resultContent = resultElement.querySelector('.result-content');
        if (resultContent) {
          resultContent.textContent = 'Ê≠£Âú®Âê¨...';
        } else {
          resultElement.innerHTML = `<div class="result-label">ËØÜÂà´ÁªìÊûú</div><div class="result-content">Ê≠£Âú®Âê¨...</div>`;
        }

        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;

        // ËÆæÁΩÆËØÜÂà´Áä∂ÊÄÅÂπ∂ÂºÄÂßãÂΩïÈü≥
        isRecognizing = true;
        startRecording();

      } catch (error) {
        debugLog(`ÂêØÂä®ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•: ${error.message}`);
        console.error("ËØ≠Èü≥ËØÜÂà´ÂêØÂä®ÈîôËØØ:", error);

        const resultElement = document.getElementById('result');
        let resultContent = resultElement.querySelector('.result-content');
        if (resultContent) {
          resultContent.textContent = `ÂêØÂä®Â§±Ë¥•: ${error.message}`;
        } else {
          resultElement.innerHTML = `<div class="result-label">ËØÜÂà´ÁªìÊûú</div><div class="result-content">ÂêØÂä®Â§±Ë¥•: ${error.message}</div>`;
        }

        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
      }
    };


    /////
    //     document.getElementById('batchBtn').onclick = () => {
    //   document.getElementById('batchModal').style.display = 'block';
    //   document.getElementById('batchFileInput').value = '';
    // };
    // document.getElementById('batchCancelBtn').onclick = () => {
    //   document.getElementById('batchModal').style.display = 'none';
    // };
    // document.getElementById('batchSubmitBtn').onclick = () => {
    //   const filePath = document.getElementById('batchFileInput').value.trim();
    //   if (filePath) {
    //     debugLog(`ÊâπÈáèÂØºÂÖ•Êñá‰ª∂Ë∑ØÂæÑ: ${filePath}`);
    //     document.getElementById('batchModal').style.display = 'none';
    //     // ÂèëÈÄÅÂà∞‰∏ªËøõÁ®ã
    //     if (hasElectronAPI) {
    //       window.api.runTraceroute(`batchfile ${filePath}`);
    //     } else {
    //       debugLog("Electron API ‰∏çÂèØÁî®ÔºåÊó†Ê≥ïÊâπÈáèÂØºÂÖ•");
    //     }
    //   }
    // };


    document.getElementById('stopBtn').onclick = () => {
      debugLog("ÂÅúÊ≠¢ËØ≠Èü≥ËØÜÂà´");

      // ÂÅúÊ≠¢ÂΩïÈü≥
      stopRecording();

      // Êõ¥Êñ∞Áä∂ÊÄÅ
      isRecognizing = false;

      // Êõ¥Êñ∞UI
      const resultElement = document.getElementById('result');
      let resultContent = resultElement.querySelector('.result-content');
      if (resultContent) {
        const currentText = resultContent.textContent;
        if (currentText && currentText !== '(Â∑≤ÂÅúÊ≠¢)' && !currentText.endsWith('(Â∑≤ÂÅúÊ≠¢)')) {
          resultContent.textContent = `${currentText} (Â∑≤ÂÅúÊ≠¢)`;
        } else if (!currentText || currentText === '(Á≠âÂæÖËØÜÂà´...)') {
          resultContent.textContent = '(Â∑≤ÂÅúÊ≠¢)';
        }
      } else {
        resultElement.innerHTML = `<div class="result-label">ËØÜÂà´ÁªìÊûú</div><div class="result-content">(Â∑≤ÂÅúÊ≠¢)</div>`;
      }

      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
    };

    // Test API button
    document.getElementById('testBtn').onclick = () => {
      debugLog("Test button clicked");
      const testDomain = "google.com";
      const resultElement = document.getElementById('result');
      let resultContent = resultElement.querySelector('.result-content');
      if (resultContent) {
        resultContent.textContent = testDomain;
      } else {
        resultElement.innerHTML = `<div class="result-label">Recognition Result</div><div class="result-content">${testDomain}</div>`;
      }
      processCommand(testDomain);
    };

    // Manual input submit button
    document.getElementById('submitBtn').onclick = () => {
      const inputField = document.getElementById('rawInput');
      const domain = inputField.value.trim();
      if (domain) {
        debugLog(`Manual domain input: ${domain}`);
        const resultElement = document.getElementById('result');
        let resultContent = resultElement.querySelector('.result-content');
        if (resultContent) {
          resultContent.textContent = domain;
        } else {
          resultElement.innerHTML = `<div class="result-label">Recognition Result</div><div class="result-content">${domain}</div>`;
        }
        processCommand(domain);
        // Clear input field
        inputField.value = '';
      } else {
        debugLog("No domain entered");
      }
    };

    // Allow Enter key for submission
    document.getElementById('rawInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('submitBtn').click();
      }
    });

    function gotSpeech() {
      debugLog("Received p5 speech recognition result");
      // Add more detailed debug information
      debugLog(`speechRec status: resultValue=${speechRec.resultValue}, resultString=${speechRec.resultString}, isRecognizing=${isRecognizing}`);

      // Display original resultString directly, whether it has a value or not
      recognitionLog(speechRec.resultString);

      // Key modification: display results regardless of isRecognizing status
      // if (isRecognizing) {
      if (speechRec.resultString) {  // As long as there's a result, display and process
        const txt = speechRec.resultString.trim();
        debugLog(`p5 recognition text: "${txt}"`);
        textResult = txt;

        // Update the way recognition results are displayed
        const resultElement = document.getElementById('result');
        // Keep label, only update content part
        let resultContent = resultElement.querySelector('.result-content');
        if (resultContent) {
          resultContent.textContent = txt || '(Waiting for recognition...)';
        } else {
          // If result-content element not found, fall back to old way
          resultElement.innerHTML = `<div class="result-label">Recognition Result</div><div class="result-content">${txt || '(Waiting for recognition...)'}</div>`;
        }

        // Only process command when text is not empty
        if (txt) {
          processCommand(txt);
        }
      } else {
        debugLog(`p5 speech recognition stopped or no result: isRecognizing=${isRecognizing}`);
      }
    }

    // If in Electron environment, set callback to receive output
    if (hasElectronAPI) {
      debugLog("Setting up Electron API output callback");
      window.api.onOutput((data) => {
        debugLog(`Received output: ${data.substring(0, 50)}...`);
        const outputElem = document.getElementById('traceOutput');
        outputElem.innerHTML += data;
        outputElem.scrollTop = outputElem.scrollHeight; // Automatically scroll to bottom
      });
    } else {
      document.getElementById('traceOutput').innerHTML = "Electron API not detected, cannot execute traceroute command.";
    }

    // Check browser speech recognition support
    debugLog("Using p5.speech for speech recognition");

    // Waveform animation part
    let curves = 150;
    let cx, cy;
    let angles = [], baseRs = [], phases1 = [], phases2 = [], speeds1 = [], speeds2 = [];
    let mic; // Declare mic here so it's accessible in draw()

    function setup() {
      createCanvas(windowWidth, windowHeight);
      cx = width / 2;
      cy = height / 2;
      for (let i = 0; i < curves; i++) {
        angles.push(map(i, 0, curves, 0, TWO_PI));
        baseRs.push(random(height * 0.15, height * 0.3));
        phases1.push(random(TWO_PI));
        phases2.push(random(TWO_PI));
        speeds1.push(random(0.02, 0.08));
        speeds2.push(random(0.02, 0.08));
      }
      stroke(255);

      // Initialize and start p5.AudioIn
      mic = new p5.AudioIn();
      mic.start();

      debugLog("p5.js canvas initialization complete and mic started");
    }

    function draw() {
      background(20);
      let vol = mic ? mic.getLevel() : 0;
      // Occasionally record volume level
      if (frameCount % 60 === 0 && mic) {
        debugLog(`Current microphone volume: ${vol.toFixed(4)}`);
      }

      let maxAmp = map(vol, 0, 0.3, 0, height * 0.15);
      for (let i = 0; i < curves; i++) {
        phases1[i] += speeds1[i];
        phases2[i] += speeds2[i];
        let r = baseRs[i];
        let off1 = 50 * sin(phases1[i]) * maxAmp + 5 * sin(random(5, 15));
        let off2 = 50 * sin(phases2[i]) * maxAmp + 5 * sin(random(5, 15));
        let cp1x = cx + cos(angles[i]) * (r + off1);
        let cp1y = cy + sin(angles[i]) * (r + off1);
        let cp2x = cx + cos(angles[i]) * (r + off2);
        let cp2y = cy + sin(angles[i]) * (r + off2);
        stroke('#05c9fa');
        bezier(cx, cy, cp1x, cp1y, cp2x, cp2y, cx, cy);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      cx = width / 2;
      cy = height / 2;
      debugLog("Window resized, canvas reset");
    }

    // Page load complete
    window.onload = function () {
      debugLog("Page loading complete");

      // Check if p5.speech is loaded correctly
      if (typeof p5.SpeechRec !== 'function') {
        debugLog("Error: p5.speech library not loaded correctly");
        document.getElementById('debugOutput').innerHTML += '<div style="color:red;font-weight:bold">Warning: p5.speech library not loaded correctly, speech recognition feature will not be available</div>';
      } else {
        debugLog("p5.speech library loaded correctly");
        // Check if speechRec is the expected object
        const testRec = new p5.SpeechRec();
        debugLog(`p5.SpeechRec test: ${Object.keys(testRec).join(", ")}`);
      }

      // Check AudioContext support
      if (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined') {
        debugLog("Browser supports AudioContext");
      } else {
        debugLog("Warning: Browser does not support AudioContext, speech recognition may not work");
      }
    };
  </script>
</body>

</html>